{"docstore/data":{"5f4b9fb5-a32d-47a8-a9f7-d62e04795676":{"indexId":"5f4b9fb5-a32d-47a8-a9f7-d62e04795676","nodesDict":{"e3d0042c-c6f4-4240-9ba9-57b0f029285d":{"id_":"e3d0042c-c6f4-4240-9ba9-57b0f029285d","metadata":{"domain":"demo","filename":"dbms_last_minute_notes_summary.pdf"},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"0de90a5b-8907-4787-be21-ffaa1eb09c24","metadata":{"domain":"demo","filename":"dbms_last_minute_notes_summary.pdf"},"hash":"Et6Efv+bwfaL6AT9pm+NvCL6pGBzwcXGYxrmL/QDImw="}},"text":"DBMS — Last-Minute Study Notes (Summary)  DBMS — Last-Minute Study Notes (Concise Summary) 1. Introduction - DBMS: Organized collection of interrelated data for efficient storage, retrieval, insertion, deletion. - Advantages over file system: concurrency, recovery, multi-user access, structured querying, data integrity. 2. ER Model (Entity-Relationship) - Entity: Real-world object (strong vs weak entities). - Attribute: Properties (key, composite, multivalued, derived). - Relationship: Association between entities; participation constraints: total vs partial. - Cardinalities: 1:1, 1:N, N:1, M:N. Mapping cardinalities determine relational table counts for ER->Relational mapping. - Specialization/Generalization and Aggregation concepts. 3. Database Design Goals & Integrity Constraints - Goals: zero redundancy, lossless join, dependency preservation. - Integrity: Entity integrity (primary key), Referential integrity (foreign key), Domain integrity, User-defined constraints. 4. Keys & Functional Dependencies - Keys: Primary, Candidate, Superkey, Alternate, Foreign key. - Functional Dependency (A -> B), types: trivial, non-trivial, multivalued, transitive. - Armstrong's axioms and attribute closure for finding keys. - Minimal cover (canonical cover) computation steps. 5. Normalization & Normal Forms - Purpose: eliminate anomalies (insert, delete, update), reduce redundancy. - 1NF: atomic values, no multi-valued attributes. - 2NF: 1NF + no partial dependency on part of a composite key. - 3NF: 2NF + no transitive dependency; every non-prime attribute must depend on a superkey. - BCNF: Every FD's LHS is a superkey (stronger than 3NF). 6. Relational Algebra & Relational Calculus - Relational algebra operators: selection ( σ ), projection ( π ), Cartesian product (×), union (U), difference (-), rename ( ρ ), joins ( n ), division (/), intersection, outer joins. - Extended operators: aggregation, set operations, etc. - Relational calculus: tuple relational calculus & domain relational calculus (non-procedural). 7. SQL Essentials - Categories: DDL (CREATE, ALTER, DROP), DML (SELECT, INSERT, UPDATE, DELETE), DCL (GRANT, REVOKE). - SQL concepts: GROUP BY, HAVING, ORDER BY, subqueries, EXISTS, LIKE, IN, BETWEEN, aliases. - Execution flow: FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY. 8. File Structure & Indexing - File organizations: sequential, heap, hash, B+ tree, clustered. - Blocking factor, record blocks, average block accesses. - Indexing: single-level (primary sparse, secondary dense, clustering) and multi-level indexes; B-Tree and B+ Tree differences. 9. Transactions & Concurrency Control - Transaction properties (ACID): Atomicity, Consistency, Isolation, Durability. - Transaction states: Active -> Partially Committed -> Committed; Failed -> Aborted. - Concurrency control aims: serializability, locks, deadlock handling (wait-die, wound-wait), two-phase locking (2PL). 10. Recovery & Logging (Brief) - Recovery ensures durability and consistency after crashes. - Write-ahead logging, checkpoints, undo/redo protocols (ARIES-style concepts). 11. Additional Quick Topics - Normalization example steps, candidate key finding, minimal cover steps. - Index usage for query performance; trade-offs (insert/update cost vs read speed). - DBMS design goals recap and practical interview pointers. Study Tips: - Practice converting ER diagrams to relational schemas. - Practice SQL queries covering joins, window functions, groupings, and subqueries. - Understand normalization through examples and write out FD decompositions. - Be able to explain transactions, locking, and recovery with simple diagrams. - Use short notes & flashcards for key definitions; implement small examples in a DB (SQLite/MySQL).","textTemplate":"","metadataSeparator":"\n","type":"TEXT","hash":"JNd2TNqb67S6ytMJPfgOtiTNRFRJdJYA9EbTimn66rI="},"ef0fe77a-4751-420a-b1e5-2af8fc9ff618":{"id_":"ef0fe77a-4751-420a-b1e5-2af8fc9ff618","metadata":{"domain":"demo","filename":"dbms_last_minute_notes_summary.pdf"},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"031beeea-afe8-4ef8-8f07-02e14691684b","metadata":{"domain":"demo","filename":"dbms_last_minute_notes_summary.pdf"},"hash":"Et6Efv+bwfaL6AT9pm+NvCL6pGBzwcXGYxrmL/QDImw="}},"text":"DBMS — Last-Minute Study Notes (Summary)  DBMS — Last-Minute Study Notes (Concise Summary) 1. Introduction - DBMS: Organized collection of interrelated data for efficient storage, retrieval, insertion, deletion. - Advantages over file system: concurrency, recovery, multi-user access, structured querying, data integrity. 2. ER Model (Entity-Relationship) - Entity: Real-world object (strong vs weak entities). - Attribute: Properties (key, composite, multivalued, derived). - Relationship: Association between entities; participation constraints: total vs partial. - Cardinalities: 1:1, 1:N, N:1, M:N. Mapping cardinalities determine relational table counts for ER->Relational mapping. - Specialization/Generalization and Aggregation concepts. 3. Database Design Goals & Integrity Constraints - Goals: zero redundancy, lossless join, dependency preservation. - Integrity: Entity integrity (primary key), Referential integrity (foreign key), Domain integrity, User-defined constraints. 4. Keys & Functional Dependencies - Keys: Primary, Candidate, Superkey, Alternate, Foreign key. - Functional Dependency (A -> B), types: trivial, non-trivial, multivalued, transitive. - Armstrong's axioms and attribute closure for finding keys. - Minimal cover (canonical cover) computation steps. 5. Normalization & Normal Forms - Purpose: eliminate anomalies (insert, delete, update), reduce redundancy. - 1NF: atomic values, no multi-valued attributes. - 2NF: 1NF + no partial dependency on part of a composite key. - 3NF: 2NF + no transitive dependency; every non-prime attribute must depend on a superkey. - BCNF: Every FD's LHS is a superkey (stronger than 3NF). 6. Relational Algebra & Relational Calculus - Relational algebra operators: selection ( σ ), projection ( π ), Cartesian product (×), union (U), difference (-), rename ( ρ ), joins ( n ), division (/), intersection, outer joins. - Extended operators: aggregation, set operations, etc. - Relational calculus: tuple relational calculus & domain relational calculus (non-procedural). 7. SQL Essentials - Categories: DDL (CREATE, ALTER, DROP), DML (SELECT, INSERT, UPDATE, DELETE), DCL (GRANT, REVOKE). - SQL concepts: GROUP BY, HAVING, ORDER BY, subqueries, EXISTS, LIKE, IN, BETWEEN, aliases. - Execution flow: FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY. 8. File Structure & Indexing - File organizations: sequential, heap, hash, B+ tree, clustered. - Blocking factor, record blocks, average block accesses. - Indexing: single-level (primary sparse, secondary dense, clustering) and multi-level indexes; B-Tree and B+ Tree differences. 9. Transactions & Concurrency Control - Transaction properties (ACID): Atomicity, Consistency, Isolation, Durability. - Transaction states: Active -> Partially Committed -> Committed; Failed -> Aborted. - Concurrency control aims: serializability, locks, deadlock handling (wait-die, wound-wait), two-phase locking (2PL). 10. Recovery & Logging (Brief) - Recovery ensures durability and consistency after crashes. - Write-ahead logging, checkpoints, undo/redo protocols (ARIES-style concepts). 11. Additional Quick Topics - Normalization example steps, candidate key finding, minimal cover steps. - Index usage for query performance; trade-offs (insert/update cost vs read speed). - DBMS design goals recap and practical interview pointers. Study Tips: - Practice converting ER diagrams to relational schemas. - Practice SQL queries covering joins, window functions, groupings, and subqueries. - Understand normalization through examples and write out FD decompositions. - Be able to explain transactions, locking, and recovery with simple diagrams. - Use short notes & flashcards for key definitions; implement small examples in a DB (SQLite/MySQL).","textTemplate":"","metadataSeparator":"\n","type":"TEXT","hash":"JNd2TNqb67S6ytMJPfgOtiTNRFRJdJYA9EbTimn66rI="},"ae035aea-3699-438e-8b0f-0abbd97c6b4c":{"id_":"ae035aea-3699-438e-8b0f-0abbd97c6b4c","metadata":{"domain":"demo","filename":"dbms_last_minute_notes_summary.pdf"},"excludedEmbedMetadataKeys":[],"excludedLlmMetadataKeys":[],"relationships":{"SOURCE":{"nodeId":"981850dc-0556-40bb-981e-cfc15d496ae8","metadata":{"domain":"demo","filename":"dbms_last_minute_notes_summary.pdf"},"hash":"Et6Efv+bwfaL6AT9pm+NvCL6pGBzwcXGYxrmL/QDImw="}},"text":"DBMS — Last-Minute Study Notes (Summary)  DBMS — Last-Minute Study Notes (Concise Summary) 1. Introduction - DBMS: Organized collection of interrelated data for efficient storage, retrieval, insertion, deletion. - Advantages over file system: concurrency, recovery, multi-user access, structured querying, data integrity. 2. ER Model (Entity-Relationship) - Entity: Real-world object (strong vs weak entities). - Attribute: Properties (key, composite, multivalued, derived). - Relationship: Association between entities; participation constraints: total vs partial. - Cardinalities: 1:1, 1:N, N:1, M:N. Mapping cardinalities determine relational table counts for ER->Relational mapping. - Specialization/Generalization and Aggregation concepts. 3. Database Design Goals & Integrity Constraints - Goals: zero redundancy, lossless join, dependency preservation. - Integrity: Entity integrity (primary key), Referential integrity (foreign key), Domain integrity, User-defined constraints. 4. Keys & Functional Dependencies - Keys: Primary, Candidate, Superkey, Alternate, Foreign key. - Functional Dependency (A -> B), types: trivial, non-trivial, multivalued, transitive. - Armstrong's axioms and attribute closure for finding keys. - Minimal cover (canonical cover) computation steps. 5. Normalization & Normal Forms - Purpose: eliminate anomalies (insert, delete, update), reduce redundancy. - 1NF: atomic values, no multi-valued attributes. - 2NF: 1NF + no partial dependency on part of a composite key. - 3NF: 2NF + no transitive dependency; every non-prime attribute must depend on a superkey. - BCNF: Every FD's LHS is a superkey (stronger than 3NF). 6. Relational Algebra & Relational Calculus - Relational algebra operators: selection ( σ ), projection ( π ), Cartesian product (×), union (U), difference (-), rename ( ρ ), joins ( n ), division (/), intersection, outer joins. - Extended operators: aggregation, set operations, etc. - Relational calculus: tuple relational calculus & domain relational calculus (non-procedural). 7. SQL Essentials - Categories: DDL (CREATE, ALTER, DROP), DML (SELECT, INSERT, UPDATE, DELETE), DCL (GRANT, REVOKE). - SQL concepts: GROUP BY, HAVING, ORDER BY, subqueries, EXISTS, LIKE, IN, BETWEEN, aliases. - Execution flow: FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY. 8. File Structure & Indexing - File organizations: sequential, heap, hash, B+ tree, clustered. - Blocking factor, record blocks, average block accesses. - Indexing: single-level (primary sparse, secondary dense, clustering) and multi-level indexes; B-Tree and B+ Tree differences. 9. Transactions & Concurrency Control - Transaction properties (ACID): Atomicity, Consistency, Isolation, Durability. - Transaction states: Active -> Partially Committed -> Committed; Failed -> Aborted. - Concurrency control aims: serializability, locks, deadlock handling (wait-die, wound-wait), two-phase locking (2PL). 10. Recovery & Logging (Brief) - Recovery ensures durability and consistency after crashes. - Write-ahead logging, checkpoints, undo/redo protocols (ARIES-style concepts). 11. Additional Quick Topics - Normalization example steps, candidate key finding, minimal cover steps. - Index usage for query performance; trade-offs (insert/update cost vs read speed). - DBMS design goals recap and practical interview pointers. Study Tips: - Practice converting ER diagrams to relational schemas. - Practice SQL queries covering joins, window functions, groupings, and subqueries. - Understand normalization through examples and write out FD decompositions. - Be able to explain transactions, locking, and recovery with simple diagrams. - Use short notes & flashcards for key definitions; implement small examples in a DB (SQLite/MySQL).","textTemplate":"","metadataSeparator":"\n","type":"TEXT","hash":"JNd2TNqb67S6ytMJPfgOtiTNRFRJdJYA9EbTimn66rI="}},"type":"simple_dict"}}}