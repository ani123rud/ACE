{"docstore/data":{"5b4911b2-72ae-4935-8d42-8c6a12e657ed":{"__data__":"{\"id_\":\"5b4911b2-72ae-4935-8d42-8c6a12e657ed\",\"metadata\":{\"domain\":\"demo\",\"filename\":\"dbms_last_minute_notes_summary.pdf\"},\"excludedEmbedMetadataKeys\":[],\"excludedLlmMetadataKeys\":[],\"relationships\":{},\"text\":\"DBMS — Last-Minute Study Notes (Summary)  DBMS — Last-Minute Study Notes (Concise Summary) 1. Introduction - DBMS: Organized collection of interrelated data for efficient storage, retrieval, insertion, deletion. - Advantages over file system: concurrency, recovery, multi-user access, structured querying, data integrity. 2. ER Model (Entity-Relationship) - Entity: Real-world object (strong vs weak entities). - Attribute: Properties (key, composite, multivalued, derived). - Relationship: Association between entities; participation constraints: total vs partial. - Cardinalities: 1:1, 1:N, N:1, M:N. Mapping cardinalities determine relational table counts for ER->Relational mapping. - Specialization/Generalization and Aggregation concepts. 3. Database Design Goals & Integrity Constraints - Goals: zero redundancy, lossless join, dependency preservation. - Integrity: Entity integrity (primary key), Referential integrity (foreign key), Domain integrity, User-defined constraints. 4. Keys & Functional Dependencies - Keys: Primary, Candidate, Superkey, Alternate, Foreign key. - Functional Dependency (A -> B), types: trivial, non-trivial, multivalued, transitive. - Armstrong's axioms and attribute closure for finding keys. - Minimal cover (canonical cover) computation steps. 5. Normalization & Normal Forms - Purpose: eliminate anomalies (insert, delete, update), reduce redundancy. - 1NF: atomic values, no multi-valued attributes. - 2NF: 1NF + no partial dependency on part of a composite key. - 3NF: 2NF + no transitive dependency; every non-prime attribute must depend on a superkey. - BCNF: Every FD's LHS is a superkey (stronger than 3NF). 6. Relational Algebra & Relational Calculus - Relational algebra operators: selection ( σ ), projection ( π ), Cartesian product (×), union (U), difference (-), rename ( ρ ), joins ( n ), division (/), intersection, outer joins. - Extended operators: aggregation, set operations, etc. - Relational calculus: tuple relational calculus & domain relational calculus (non-procedural). 7. SQL Essentials - Categories: DDL (CREATE, ALTER, DROP), DML (SELECT, INSERT, UPDATE, DELETE), DCL (GRANT, REVOKE). - SQL concepts: GROUP BY, HAVING, ORDER BY, subqueries, EXISTS, LIKE, IN, BETWEEN, aliases. - Execution flow: FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY. 8. File Structure & Indexing - File organizations: sequential, heap, hash, B+ tree, clustered. - Blocking factor, record blocks, average block accesses. - Indexing: single-level (primary sparse, secondary dense, clustering) and multi-level indexes; B-Tree and B+ Tree differences. 9. Transactions & Concurrency Control - Transaction properties (ACID): Atomicity, Consistency, Isolation, Durability. - Transaction states: Active -> Partially Committed -> Committed; Failed -> Aborted. - Concurrency control aims: serializability, locks, deadlock handling (wait-die, wound-wait), two-phase locking (2PL). 10. Recovery & Logging (Brief) - Recovery ensures durability and consistency after crashes. - Write-ahead logging, checkpoints, undo/redo protocols (ARIES-style concepts). 11. Additional Quick Topics - Normalization example steps, candidate key finding, minimal cover steps.\\n- Index usage for query performance; trade-offs (insert/update cost vs read speed). - DBMS design goals recap and practical interview pointers. Study Tips: - Practice converting ER diagrams to relational schemas. - Practice SQL queries covering joins, window functions, groupings, and subqueries. - Understand normalization through examples and write out FD decompositions. - Be able to explain transactions, locking, and recovery with simple diagrams. - Use short notes & flashcards for key definitions; implement small examples in a DB (SQLite/MySQL).\\n\",\"textTemplate\":\"\",\"metadataSeparator\":\"\\n\",\"type\":\"DOCUMENT\",\"hash\":\"Et6Efv+bwfaL6AT9pm+NvCL6pGBzwcXGYxrmL/QDImw=\"}","__type__":"DOCUMENT"},"760cbdee-b658-4a0a-b15a-231877563984":{"__data__":"{\"id_\":\"760cbdee-b658-4a0a-b15a-231877563984\",\"metadata\":{\"domain\":\"demo\",\"filename\":\"dbms_last_minute_notes_summary.pdf\"},\"excludedEmbedMetadataKeys\":[],\"excludedLlmMetadataKeys\":[],\"relationships\":{},\"text\":\"DBMS — Last-Minute Study Notes (Summary)  DBMS — Last-Minute Study Notes (Concise Summary) 1. Introduction - DBMS: Organized collection of interrelated data for efficient storage, retrieval, insertion, deletion. - Advantages over file system: concurrency, recovery, multi-user access, structured querying, data integrity. 2. ER Model (Entity-Relationship) - Entity: Real-world object (strong vs weak entities). - Attribute: Properties (key, composite, multivalued, derived). - Relationship: Association between entities; participation constraints: total vs partial. - Cardinalities: 1:1, 1:N, N:1, M:N. Mapping cardinalities determine relational table counts for ER->Relational mapping. - Specialization/Generalization and Aggregation concepts. 3. Database Design Goals & Integrity Constraints - Goals: zero redundancy, lossless join, dependency preservation. - Integrity: Entity integrity (primary key), Referential integrity (foreign key), Domain integrity, User-defined constraints. 4. Keys & Functional Dependencies - Keys: Primary, Candidate, Superkey, Alternate, Foreign key. - Functional Dependency (A -> B), types: trivial, non-trivial, multivalued, transitive. - Armstrong's axioms and attribute closure for finding keys. - Minimal cover (canonical cover) computation steps. 5. Normalization & Normal Forms - Purpose: eliminate anomalies (insert, delete, update), reduce redundancy. - 1NF: atomic values, no multi-valued attributes. - 2NF: 1NF + no partial dependency on part of a composite key. - 3NF: 2NF + no transitive dependency; every non-prime attribute must depend on a superkey. - BCNF: Every FD's LHS is a superkey (stronger than 3NF). 6. Relational Algebra & Relational Calculus - Relational algebra operators: selection ( σ ), projection ( π ), Cartesian product (×), union (U), difference (-), rename ( ρ ), joins ( n ), division (/), intersection, outer joins. - Extended operators: aggregation, set operations, etc. - Relational calculus: tuple relational calculus & domain relational calculus (non-procedural). 7. SQL Essentials - Categories: DDL (CREATE, ALTER, DROP), DML (SELECT, INSERT, UPDATE, DELETE), DCL (GRANT, REVOKE). - SQL concepts: GROUP BY, HAVING, ORDER BY, subqueries, EXISTS, LIKE, IN, BETWEEN, aliases. - Execution flow: FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY. 8. File Structure & Indexing - File organizations: sequential, heap, hash, B+ tree, clustered. - Blocking factor, record blocks, average block accesses. - Indexing: single-level (primary sparse, secondary dense, clustering) and multi-level indexes; B-Tree and B+ Tree differences. 9. Transactions & Concurrency Control - Transaction properties (ACID): Atomicity, Consistency, Isolation, Durability. - Transaction states: Active -> Partially Committed -> Committed; Failed -> Aborted. - Concurrency control aims: serializability, locks, deadlock handling (wait-die, wound-wait), two-phase locking (2PL). 10. Recovery & Logging (Brief) - Recovery ensures durability and consistency after crashes. - Write-ahead logging, checkpoints, undo/redo protocols (ARIES-style concepts). 11. Additional Quick Topics - Normalization example steps, candidate key finding, minimal cover steps.\\n- Index usage for query performance; trade-offs (insert/update cost vs read speed). - DBMS design goals recap and practical interview pointers. Study Tips: - Practice converting ER diagrams to relational schemas. - Practice SQL queries covering joins, window functions, groupings, and subqueries. - Understand normalization through examples and write out FD decompositions. - Be able to explain transactions, locking, and recovery with simple diagrams. - Use short notes & flashcards for key definitions; implement small examples in a DB (SQLite/MySQL).\\n\",\"textTemplate\":\"\",\"metadataSeparator\":\"\\n\",\"type\":\"DOCUMENT\",\"hash\":\"Et6Efv+bwfaL6AT9pm+NvCL6pGBzwcXGYxrmL/QDImw=\"}","__type__":"DOCUMENT"},"7dba9184-3420-44ac-88cc-7dee8c368684":{"__data__":"{\"id_\":\"7dba9184-3420-44ac-88cc-7dee8c368684\",\"metadata\":{\"domain\":\"demo\",\"filename\":\"dbms_last_minute_notes_summary.pdf\"},\"excludedEmbedMetadataKeys\":[],\"excludedLlmMetadataKeys\":[],\"relationships\":{},\"text\":\"DBMS — Last-Minute Study Notes (Summary)  DBMS — Last-Minute Study Notes (Concise Summary) 1. Introduction - DBMS: Organized collection of interrelated data for efficient storage, retrieval, insertion, deletion. - Advantages over file system: concurrency, recovery, multi-user access, structured querying, data integrity. 2. ER Model (Entity-Relationship) - Entity: Real-world object (strong vs weak entities). - Attribute: Properties (key, composite, multivalued, derived). - Relationship: Association between entities; participation constraints: total vs partial. - Cardinalities: 1:1, 1:N, N:1, M:N. Mapping cardinalities determine relational table counts for ER->Relational mapping. - Specialization/Generalization and Aggregation concepts. 3. Database Design Goals & Integrity Constraints - Goals: zero redundancy, lossless join, dependency preservation. - Integrity: Entity integrity (primary key), Referential integrity (foreign key), Domain integrity, User-defined constraints. 4. Keys & Functional Dependencies - Keys: Primary, Candidate, Superkey, Alternate, Foreign key. - Functional Dependency (A -> B), types: trivial, non-trivial, multivalued, transitive. - Armstrong's axioms and attribute closure for finding keys. - Minimal cover (canonical cover) computation steps. 5. Normalization & Normal Forms - Purpose: eliminate anomalies (insert, delete, update), reduce redundancy. - 1NF: atomic values, no multi-valued attributes. - 2NF: 1NF + no partial dependency on part of a composite key. - 3NF: 2NF + no transitive dependency; every non-prime attribute must depend on a superkey. - BCNF: Every FD's LHS is a superkey (stronger than 3NF). 6. Relational Algebra & Relational Calculus - Relational algebra operators: selection ( σ ), projection ( π ), Cartesian product (×), union (U), difference (-), rename ( ρ ), joins ( n ), division (/), intersection, outer joins. - Extended operators: aggregation, set operations, etc. - Relational calculus: tuple relational calculus & domain relational calculus (non-procedural). 7. SQL Essentials - Categories: DDL (CREATE, ALTER, DROP), DML (SELECT, INSERT, UPDATE, DELETE), DCL (GRANT, REVOKE). - SQL concepts: GROUP BY, HAVING, ORDER BY, subqueries, EXISTS, LIKE, IN, BETWEEN, aliases. - Execution flow: FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY. 8. File Structure & Indexing - File organizations: sequential, heap, hash, B+ tree, clustered. - Blocking factor, record blocks, average block accesses. - Indexing: single-level (primary sparse, secondary dense, clustering) and multi-level indexes; B-Tree and B+ Tree differences. 9. Transactions & Concurrency Control - Transaction properties (ACID): Atomicity, Consistency, Isolation, Durability. - Transaction states: Active -> Partially Committed -> Committed; Failed -> Aborted. - Concurrency control aims: serializability, locks, deadlock handling (wait-die, wound-wait), two-phase locking (2PL). 10. Recovery & Logging (Brief) - Recovery ensures durability and consistency after crashes. - Write-ahead logging, checkpoints, undo/redo protocols (ARIES-style concepts). 11. Additional Quick Topics - Normalization example steps, candidate key finding, minimal cover steps.\\n- Index usage for query performance; trade-offs (insert/update cost vs read speed). - DBMS design goals recap and practical interview pointers. Study Tips: - Practice converting ER diagrams to relational schemas. - Practice SQL queries covering joins, window functions, groupings, and subqueries. - Understand normalization through examples and write out FD decompositions. - Be able to explain transactions, locking, and recovery with simple diagrams. - Use short notes & flashcards for key definitions; implement small examples in a DB (SQLite/MySQL).\\n\",\"textTemplate\":\"\",\"metadataSeparator\":\"\\n\",\"type\":\"DOCUMENT\",\"hash\":\"Et6Efv+bwfaL6AT9pm+NvCL6pGBzwcXGYxrmL/QDImw=\"}","__type__":"DOCUMENT"},"0de90a5b-8907-4787-be21-ffaa1eb09c24":{"__data__":"{\"id_\":\"0de90a5b-8907-4787-be21-ffaa1eb09c24\",\"metadata\":{\"domain\":\"demo\",\"filename\":\"dbms_last_minute_notes_summary.pdf\"},\"excludedEmbedMetadataKeys\":[],\"excludedLlmMetadataKeys\":[],\"relationships\":{},\"text\":\"DBMS — Last-Minute Study Notes (Summary)  DBMS — Last-Minute Study Notes (Concise Summary) 1. Introduction - DBMS: Organized collection of interrelated data for efficient storage, retrieval, insertion, deletion. - Advantages over file system: concurrency, recovery, multi-user access, structured querying, data integrity. 2. ER Model (Entity-Relationship) - Entity: Real-world object (strong vs weak entities). - Attribute: Properties (key, composite, multivalued, derived). - Relationship: Association between entities; participation constraints: total vs partial. - Cardinalities: 1:1, 1:N, N:1, M:N. Mapping cardinalities determine relational table counts for ER->Relational mapping. - Specialization/Generalization and Aggregation concepts. 3. Database Design Goals & Integrity Constraints - Goals: zero redundancy, lossless join, dependency preservation. - Integrity: Entity integrity (primary key), Referential integrity (foreign key), Domain integrity, User-defined constraints. 4. Keys & Functional Dependencies - Keys: Primary, Candidate, Superkey, Alternate, Foreign key. - Functional Dependency (A -> B), types: trivial, non-trivial, multivalued, transitive. - Armstrong's axioms and attribute closure for finding keys. - Minimal cover (canonical cover) computation steps. 5. Normalization & Normal Forms - Purpose: eliminate anomalies (insert, delete, update), reduce redundancy. - 1NF: atomic values, no multi-valued attributes. - 2NF: 1NF + no partial dependency on part of a composite key. - 3NF: 2NF + no transitive dependency; every non-prime attribute must depend on a superkey. - BCNF: Every FD's LHS is a superkey (stronger than 3NF). 6. Relational Algebra & Relational Calculus - Relational algebra operators: selection ( σ ), projection ( π ), Cartesian product (×), union (U), difference (-), rename ( ρ ), joins ( n ), division (/), intersection, outer joins. - Extended operators: aggregation, set operations, etc. - Relational calculus: tuple relational calculus & domain relational calculus (non-procedural). 7. SQL Essentials - Categories: DDL (CREATE, ALTER, DROP), DML (SELECT, INSERT, UPDATE, DELETE), DCL (GRANT, REVOKE). - SQL concepts: GROUP BY, HAVING, ORDER BY, subqueries, EXISTS, LIKE, IN, BETWEEN, aliases. - Execution flow: FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY. 8. File Structure & Indexing - File organizations: sequential, heap, hash, B+ tree, clustered. - Blocking factor, record blocks, average block accesses. - Indexing: single-level (primary sparse, secondary dense, clustering) and multi-level indexes; B-Tree and B+ Tree differences. 9. Transactions & Concurrency Control - Transaction properties (ACID): Atomicity, Consistency, Isolation, Durability. - Transaction states: Active -> Partially Committed -> Committed; Failed -> Aborted. - Concurrency control aims: serializability, locks, deadlock handling (wait-die, wound-wait), two-phase locking (2PL). 10. Recovery & Logging (Brief) - Recovery ensures durability and consistency after crashes. - Write-ahead logging, checkpoints, undo/redo protocols (ARIES-style concepts). 11. Additional Quick Topics - Normalization example steps, candidate key finding, minimal cover steps.\\n- Index usage for query performance; trade-offs (insert/update cost vs read speed). - DBMS design goals recap and practical interview pointers. Study Tips: - Practice converting ER diagrams to relational schemas. - Practice SQL queries covering joins, window functions, groupings, and subqueries. - Understand normalization through examples and write out FD decompositions. - Be able to explain transactions, locking, and recovery with simple diagrams. - Use short notes & flashcards for key definitions; implement small examples in a DB (SQLite/MySQL).\\n\",\"textTemplate\":\"\",\"metadataSeparator\":\"\\n\",\"type\":\"DOCUMENT\",\"hash\":\"Et6Efv+bwfaL6AT9pm+NvCL6pGBzwcXGYxrmL/QDImw=\"}","__type__":"DOCUMENT"},"e3d0042c-c6f4-4240-9ba9-57b0f029285d":{"__data__":"{\"id_\":\"e3d0042c-c6f4-4240-9ba9-57b0f029285d\",\"metadata\":{\"domain\":\"demo\",\"filename\":\"dbms_last_minute_notes_summary.pdf\"},\"excludedEmbedMetadataKeys\":[],\"excludedLlmMetadataKeys\":[],\"relationships\":{\"SOURCE\":{\"nodeId\":\"0de90a5b-8907-4787-be21-ffaa1eb09c24\",\"metadata\":{\"domain\":\"demo\",\"filename\":\"dbms_last_minute_notes_summary.pdf\"},\"hash\":\"Et6Efv+bwfaL6AT9pm+NvCL6pGBzwcXGYxrmL/QDImw=\"}},\"text\":\"DBMS — Last-Minute Study Notes (Summary)  DBMS — Last-Minute Study Notes (Concise Summary) 1. Introduction - DBMS: Organized collection of interrelated data for efficient storage, retrieval, insertion, deletion. - Advantages over file system: concurrency, recovery, multi-user access, structured querying, data integrity. 2. ER Model (Entity-Relationship) - Entity: Real-world object (strong vs weak entities). - Attribute: Properties (key, composite, multivalued, derived). - Relationship: Association between entities; participation constraints: total vs partial. - Cardinalities: 1:1, 1:N, N:1, M:N. Mapping cardinalities determine relational table counts for ER->Relational mapping. - Specialization/Generalization and Aggregation concepts. 3. Database Design Goals & Integrity Constraints - Goals: zero redundancy, lossless join, dependency preservation. - Integrity: Entity integrity (primary key), Referential integrity (foreign key), Domain integrity, User-defined constraints. 4. Keys & Functional Dependencies - Keys: Primary, Candidate, Superkey, Alternate, Foreign key. - Functional Dependency (A -> B), types: trivial, non-trivial, multivalued, transitive. - Armstrong's axioms and attribute closure for finding keys. - Minimal cover (canonical cover) computation steps. 5. Normalization & Normal Forms - Purpose: eliminate anomalies (insert, delete, update), reduce redundancy. - 1NF: atomic values, no multi-valued attributes. - 2NF: 1NF + no partial dependency on part of a composite key. - 3NF: 2NF + no transitive dependency; every non-prime attribute must depend on a superkey. - BCNF: Every FD's LHS is a superkey (stronger than 3NF). 6. Relational Algebra & Relational Calculus - Relational algebra operators: selection ( σ ), projection ( π ), Cartesian product (×), union (U), difference (-), rename ( ρ ), joins ( n ), division (/), intersection, outer joins. - Extended operators: aggregation, set operations, etc. - Relational calculus: tuple relational calculus & domain relational calculus (non-procedural). 7. SQL Essentials - Categories: DDL (CREATE, ALTER, DROP), DML (SELECT, INSERT, UPDATE, DELETE), DCL (GRANT, REVOKE). - SQL concepts: GROUP BY, HAVING, ORDER BY, subqueries, EXISTS, LIKE, IN, BETWEEN, aliases. - Execution flow: FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY. 8. File Structure & Indexing - File organizations: sequential, heap, hash, B+ tree, clustered. - Blocking factor, record blocks, average block accesses. - Indexing: single-level (primary sparse, secondary dense, clustering) and multi-level indexes; B-Tree and B+ Tree differences. 9. Transactions & Concurrency Control - Transaction properties (ACID): Atomicity, Consistency, Isolation, Durability. - Transaction states: Active -> Partially Committed -> Committed; Failed -> Aborted. - Concurrency control aims: serializability, locks, deadlock handling (wait-die, wound-wait), two-phase locking (2PL). 10. Recovery & Logging (Brief) - Recovery ensures durability and consistency after crashes. - Write-ahead logging, checkpoints, undo/redo protocols (ARIES-style concepts). 11. Additional Quick Topics - Normalization example steps, candidate key finding, minimal cover steps. - Index usage for query performance; trade-offs (insert/update cost vs read speed). - DBMS design goals recap and practical interview pointers. Study Tips: - Practice converting ER diagrams to relational schemas. - Practice SQL queries covering joins, window functions, groupings, and subqueries. - Understand normalization through examples and write out FD decompositions. - Be able to explain transactions, locking, and recovery with simple diagrams. - Use short notes & flashcards for key definitions; implement small examples in a DB (SQLite/MySQL).\",\"textTemplate\":\"\",\"metadataSeparator\":\"\\n\",\"type\":\"TEXT\",\"hash\":\"JNd2TNqb67S6ytMJPfgOtiTNRFRJdJYA9EbTimn66rI=\"}","__type__":"TEXT"},"ef0fe77a-4751-420a-b1e5-2af8fc9ff618":{"__data__":"{\"id_\":\"ef0fe77a-4751-420a-b1e5-2af8fc9ff618\",\"metadata\":{\"domain\":\"demo\",\"filename\":\"dbms_last_minute_notes_summary.pdf\"},\"excludedEmbedMetadataKeys\":[],\"excludedLlmMetadataKeys\":[],\"relationships\":{\"SOURCE\":{\"nodeId\":\"031beeea-afe8-4ef8-8f07-02e14691684b\",\"metadata\":{\"domain\":\"demo\",\"filename\":\"dbms_last_minute_notes_summary.pdf\"},\"hash\":\"Et6Efv+bwfaL6AT9pm+NvCL6pGBzwcXGYxrmL/QDImw=\"}},\"text\":\"DBMS — Last-Minute Study Notes (Summary)  DBMS — Last-Minute Study Notes (Concise Summary) 1. Introduction - DBMS: Organized collection of interrelated data for efficient storage, retrieval, insertion, deletion. - Advantages over file system: concurrency, recovery, multi-user access, structured querying, data integrity. 2. ER Model (Entity-Relationship) - Entity: Real-world object (strong vs weak entities). - Attribute: Properties (key, composite, multivalued, derived). - Relationship: Association between entities; participation constraints: total vs partial. - Cardinalities: 1:1, 1:N, N:1, M:N. Mapping cardinalities determine relational table counts for ER->Relational mapping. - Specialization/Generalization and Aggregation concepts. 3. Database Design Goals & Integrity Constraints - Goals: zero redundancy, lossless join, dependency preservation. - Integrity: Entity integrity (primary key), Referential integrity (foreign key), Domain integrity, User-defined constraints. 4. Keys & Functional Dependencies - Keys: Primary, Candidate, Superkey, Alternate, Foreign key. - Functional Dependency (A -> B), types: trivial, non-trivial, multivalued, transitive. - Armstrong's axioms and attribute closure for finding keys. - Minimal cover (canonical cover) computation steps. 5. Normalization & Normal Forms - Purpose: eliminate anomalies (insert, delete, update), reduce redundancy. - 1NF: atomic values, no multi-valued attributes. - 2NF: 1NF + no partial dependency on part of a composite key. - 3NF: 2NF + no transitive dependency; every non-prime attribute must depend on a superkey. - BCNF: Every FD's LHS is a superkey (stronger than 3NF). 6. Relational Algebra & Relational Calculus - Relational algebra operators: selection ( σ ), projection ( π ), Cartesian product (×), union (U), difference (-), rename ( ρ ), joins ( n ), division (/), intersection, outer joins. - Extended operators: aggregation, set operations, etc. - Relational calculus: tuple relational calculus & domain relational calculus (non-procedural). 7. SQL Essentials - Categories: DDL (CREATE, ALTER, DROP), DML (SELECT, INSERT, UPDATE, DELETE), DCL (GRANT, REVOKE). - SQL concepts: GROUP BY, HAVING, ORDER BY, subqueries, EXISTS, LIKE, IN, BETWEEN, aliases. - Execution flow: FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY. 8. File Structure & Indexing - File organizations: sequential, heap, hash, B+ tree, clustered. - Blocking factor, record blocks, average block accesses. - Indexing: single-level (primary sparse, secondary dense, clustering) and multi-level indexes; B-Tree and B+ Tree differences. 9. Transactions & Concurrency Control - Transaction properties (ACID): Atomicity, Consistency, Isolation, Durability. - Transaction states: Active -> Partially Committed -> Committed; Failed -> Aborted. - Concurrency control aims: serializability, locks, deadlock handling (wait-die, wound-wait), two-phase locking (2PL). 10. Recovery & Logging (Brief) - Recovery ensures durability and consistency after crashes. - Write-ahead logging, checkpoints, undo/redo protocols (ARIES-style concepts). 11. Additional Quick Topics - Normalization example steps, candidate key finding, minimal cover steps. - Index usage for query performance; trade-offs (insert/update cost vs read speed). - DBMS design goals recap and practical interview pointers. Study Tips: - Practice converting ER diagrams to relational schemas. - Practice SQL queries covering joins, window functions, groupings, and subqueries. - Understand normalization through examples and write out FD decompositions. - Be able to explain transactions, locking, and recovery with simple diagrams. - Use short notes & flashcards for key definitions; implement small examples in a DB (SQLite/MySQL).\",\"textTemplate\":\"\",\"metadataSeparator\":\"\\n\",\"type\":\"TEXT\",\"hash\":\"JNd2TNqb67S6ytMJPfgOtiTNRFRJdJYA9EbTimn66rI=\"}","__type__":"TEXT"},"ae035aea-3699-438e-8b0f-0abbd97c6b4c":{"__data__":"{\"id_\":\"ae035aea-3699-438e-8b0f-0abbd97c6b4c\",\"metadata\":{\"domain\":\"demo\",\"filename\":\"dbms_last_minute_notes_summary.pdf\"},\"excludedEmbedMetadataKeys\":[],\"excludedLlmMetadataKeys\":[],\"relationships\":{\"SOURCE\":{\"nodeId\":\"981850dc-0556-40bb-981e-cfc15d496ae8\",\"metadata\":{\"domain\":\"demo\",\"filename\":\"dbms_last_minute_notes_summary.pdf\"},\"hash\":\"Et6Efv+bwfaL6AT9pm+NvCL6pGBzwcXGYxrmL/QDImw=\"}},\"text\":\"DBMS — Last-Minute Study Notes (Summary)  DBMS — Last-Minute Study Notes (Concise Summary) 1. Introduction - DBMS: Organized collection of interrelated data for efficient storage, retrieval, insertion, deletion. - Advantages over file system: concurrency, recovery, multi-user access, structured querying, data integrity. 2. ER Model (Entity-Relationship) - Entity: Real-world object (strong vs weak entities). - Attribute: Properties (key, composite, multivalued, derived). - Relationship: Association between entities; participation constraints: total vs partial. - Cardinalities: 1:1, 1:N, N:1, M:N. Mapping cardinalities determine relational table counts for ER->Relational mapping. - Specialization/Generalization and Aggregation concepts. 3. Database Design Goals & Integrity Constraints - Goals: zero redundancy, lossless join, dependency preservation. - Integrity: Entity integrity (primary key), Referential integrity (foreign key), Domain integrity, User-defined constraints. 4. Keys & Functional Dependencies - Keys: Primary, Candidate, Superkey, Alternate, Foreign key. - Functional Dependency (A -> B), types: trivial, non-trivial, multivalued, transitive. - Armstrong's axioms and attribute closure for finding keys. - Minimal cover (canonical cover) computation steps. 5. Normalization & Normal Forms - Purpose: eliminate anomalies (insert, delete, update), reduce redundancy. - 1NF: atomic values, no multi-valued attributes. - 2NF: 1NF + no partial dependency on part of a composite key. - 3NF: 2NF + no transitive dependency; every non-prime attribute must depend on a superkey. - BCNF: Every FD's LHS is a superkey (stronger than 3NF). 6. Relational Algebra & Relational Calculus - Relational algebra operators: selection ( σ ), projection ( π ), Cartesian product (×), union (U), difference (-), rename ( ρ ), joins ( n ), division (/), intersection, outer joins. - Extended operators: aggregation, set operations, etc. - Relational calculus: tuple relational calculus & domain relational calculus (non-procedural). 7. SQL Essentials - Categories: DDL (CREATE, ALTER, DROP), DML (SELECT, INSERT, UPDATE, DELETE), DCL (GRANT, REVOKE). - SQL concepts: GROUP BY, HAVING, ORDER BY, subqueries, EXISTS, LIKE, IN, BETWEEN, aliases. - Execution flow: FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY. 8. File Structure & Indexing - File organizations: sequential, heap, hash, B+ tree, clustered. - Blocking factor, record blocks, average block accesses. - Indexing: single-level (primary sparse, secondary dense, clustering) and multi-level indexes; B-Tree and B+ Tree differences. 9. Transactions & Concurrency Control - Transaction properties (ACID): Atomicity, Consistency, Isolation, Durability. - Transaction states: Active -> Partially Committed -> Committed; Failed -> Aborted. - Concurrency control aims: serializability, locks, deadlock handling (wait-die, wound-wait), two-phase locking (2PL). 10. Recovery & Logging (Brief) - Recovery ensures durability and consistency after crashes. - Write-ahead logging, checkpoints, undo/redo protocols (ARIES-style concepts). 11. Additional Quick Topics - Normalization example steps, candidate key finding, minimal cover steps. - Index usage for query performance; trade-offs (insert/update cost vs read speed). - DBMS design goals recap and practical interview pointers. Study Tips: - Practice converting ER diagrams to relational schemas. - Practice SQL queries covering joins, window functions, groupings, and subqueries. - Understand normalization through examples and write out FD decompositions. - Be able to explain transactions, locking, and recovery with simple diagrams. - Use short notes & flashcards for key definitions; implement small examples in a DB (SQLite/MySQL).\",\"textTemplate\":\"\",\"metadataSeparator\":\"\\n\",\"type\":\"TEXT\",\"hash\":\"JNd2TNqb67S6ytMJPfgOtiTNRFRJdJYA9EbTimn66rI=\"}","__type__":"TEXT"}},"docstore/metadata":{"5b4911b2-72ae-4935-8d42-8c6a12e657ed":{"docHash":"Et6Efv+bwfaL6AT9pm+NvCL6pGBzwcXGYxrmL/QDImw="},"760cbdee-b658-4a0a-b15a-231877563984":{"docHash":"Et6Efv+bwfaL6AT9pm+NvCL6pGBzwcXGYxrmL/QDImw="},"7dba9184-3420-44ac-88cc-7dee8c368684":{"docHash":"Et6Efv+bwfaL6AT9pm+NvCL6pGBzwcXGYxrmL/QDImw="},"0de90a5b-8907-4787-be21-ffaa1eb09c24":{"docHash":"Et6Efv+bwfaL6AT9pm+NvCL6pGBzwcXGYxrmL/QDImw="},"e3d0042c-c6f4-4240-9ba9-57b0f029285d":{"docHash":"JNd2TNqb67S6ytMJPfgOtiTNRFRJdJYA9EbTimn66rI=","refDocId":"0de90a5b-8907-4787-be21-ffaa1eb09c24"},"ef0fe77a-4751-420a-b1e5-2af8fc9ff618":{"docHash":"JNd2TNqb67S6ytMJPfgOtiTNRFRJdJYA9EbTimn66rI=","refDocId":"031beeea-afe8-4ef8-8f07-02e14691684b"},"031beeea-afe8-4ef8-8f07-02e14691684b":{"docHash":"Et6Efv+bwfaL6AT9pm+NvCL6pGBzwcXGYxrmL/QDImw="},"ae035aea-3699-438e-8b0f-0abbd97c6b4c":{"docHash":"JNd2TNqb67S6ytMJPfgOtiTNRFRJdJYA9EbTimn66rI=","refDocId":"981850dc-0556-40bb-981e-cfc15d496ae8"},"981850dc-0556-40bb-981e-cfc15d496ae8":{"docHash":"Et6Efv+bwfaL6AT9pm+NvCL6pGBzwcXGYxrmL/QDImw="}},"docstore/ref_doc_info":{"0de90a5b-8907-4787-be21-ffaa1eb09c24":{"nodeIds":["e3d0042c-c6f4-4240-9ba9-57b0f029285d"],"extraInfo":{}},"031beeea-afe8-4ef8-8f07-02e14691684b":{"nodeIds":["ef0fe77a-4751-420a-b1e5-2af8fc9ff618"],"extraInfo":{}},"981850dc-0556-40bb-981e-cfc15d496ae8":{"nodeIds":["ae035aea-3699-438e-8b0f-0abbd97c6b4c"],"extraInfo":{}}}}