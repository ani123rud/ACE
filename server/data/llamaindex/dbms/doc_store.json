{"docstore/data":{"ced9502c-fbc9-4353-b116-42e210854a90":{"__data__":"{\"id_\":\"ced9502c-fbc9-4353-b116-42e210854a90\",\"metadata\":{\"domain\":\"dbms\",\"filename\":\"dbms_last_minute_notes_summary.pdf\"},\"excludedEmbedMetadataKeys\":[],\"excludedLlmMetadataKeys\":[],\"relationships\":{},\"text\":\"DBMS — Last-Minute Study Notes (Summary)  DBMS — Last-Minute Study Notes (Concise Summary) 1. Introduction - DBMS: Organized collection of interrelated data for efficient storage, retrieval, insertion, deletion. - Advantages over file system: concurrency, recovery, multi-user access, structured querying, data integrity. 2. ER Model (Entity-Relationship) - Entity: Real-world object (strong vs weak entities). - Attribute: Properties (key, composite, multivalued, derived). - Relationship: Association between entities; participation constraints: total vs partial. - Cardinalities: 1:1, 1:N, N:1, M:N. Mapping cardinalities determine relational table counts for ER->Relational mapping. - Specialization/Generalization and Aggregation concepts. 3. Database Design Goals & Integrity Constraints - Goals: zero redundancy, lossless join, dependency preservation. - Integrity: Entity integrity (primary key), Referential integrity (foreign key), Domain integrity, User-defined constraints. 4. Keys & Functional Dependencies - Keys: Primary, Candidate, Superkey, Alternate, Foreign key. - Functional Dependency (A -> B), types: trivial, non-trivial, multivalued, transitive. - Armstrong's axioms and attribute closure for finding keys. - Minimal cover (canonical cover) computation steps. 5. Normalization & Normal Forms - Purpose: eliminate anomalies (insert, delete, update), reduce redundancy. - 1NF: atomic values, no multi-valued attributes. - 2NF: 1NF + no partial dependency on part of a composite key. - 3NF: 2NF + no transitive dependency; every non-prime attribute must depend on a superkey. - BCNF: Every FD's LHS is a superkey (stronger than 3NF). 6. Relational Algebra & Relational Calculus - Relational algebra operators: selection ( σ ), projection ( π ), Cartesian product (×), union (U), difference (-), rename ( ρ ), joins ( n ), division (/), intersection, outer joins. - Extended operators: aggregation, set operations, etc. - Relational calculus: tuple relational calculus & domain relational calculus (non-procedural). 7. SQL Essentials - Categories: DDL (CREATE, ALTER, DROP), DML (SELECT, INSERT, UPDATE, DELETE), DCL (GRANT, REVOKE). - SQL concepts: GROUP BY, HAVING, ORDER BY, subqueries, EXISTS, LIKE, IN, BETWEEN, aliases. - Execution flow: FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY. 8. File Structure & Indexing - File organizations: sequential, heap, hash, B+ tree, clustered. - Blocking factor, record blocks, average block accesses. - Indexing: single-level (primary sparse, secondary dense, clustering) and multi-level indexes; B-Tree and B+ Tree differences. 9. Transactions & Concurrency Control - Transaction properties (ACID): Atomicity, Consistency, Isolation, Durability. - Transaction states: Active -> Partially Committed -> Committed; Failed -> Aborted. - Concurrency control aims: serializability, locks, deadlock handling (wait-die, wound-wait), two-phase locking (2PL). 10. Recovery & Logging (Brief) - Recovery ensures durability and consistency after crashes. - Write-ahead logging, checkpoints, undo/redo protocols (ARIES-style concepts). 11. Additional Quick Topics - Normalization example steps, candidate key finding, minimal cover steps.\\n- Index usage for query performance; trade-offs (insert/update cost vs read speed). - DBMS design goals recap and practical interview pointers. Study Tips: - Practice converting ER diagrams to relational schemas. - Practice SQL queries covering joins, window functions, groupings, and subqueries. - Understand normalization through examples and write out FD decompositions. - Be able to explain transactions, locking, and recovery with simple diagrams. - Use short notes & flashcards for key definitions; implement small examples in a DB (SQLite/MySQL).\\n\",\"textTemplate\":\"\",\"metadataSeparator\":\"\\n\",\"type\":\"DOCUMENT\",\"hash\":\"WQHSBEaYQaFTCo5bPFMQyCbDuEA/6AZiTkmQRkxF1i0=\"}","__type__":"DOCUMENT"},"a7d12320-a9ef-4489-a525-6949afb97dc2":{"__data__":"{\"id_\":\"a7d12320-a9ef-4489-a525-6949afb97dc2\",\"metadata\":{\"domain\":\"dbms\",\"filename\":\"dbms_last_minute_notes_summary.pdf\"},\"excludedEmbedMetadataKeys\":[],\"excludedLlmMetadataKeys\":[],\"relationships\":{\"SOURCE\":{\"nodeId\":\"ced9502c-fbc9-4353-b116-42e210854a90\",\"metadata\":{\"domain\":\"dbms\",\"filename\":\"dbms_last_minute_notes_summary.pdf\"},\"hash\":\"WQHSBEaYQaFTCo5bPFMQyCbDuEA/6AZiTkmQRkxF1i0=\"}},\"text\":\"DBMS — Last-Minute Study Notes (Summary)  DBMS — Last-Minute Study Notes (Concise Summary) 1. Introduction - DBMS: Organized collection of interrelated data for efficient storage, retrieval, insertion, deletion. - Advantages over file system: concurrency, recovery, multi-user access, structured querying, data integrity. 2. ER Model (Entity-Relationship) - Entity: Real-world object (strong vs weak entities). - Attribute: Properties (key, composite, multivalued, derived). - Relationship: Association between entities; participation constraints: total vs partial. - Cardinalities: 1:1, 1:N, N:1, M:N. Mapping cardinalities determine relational table counts for ER->Relational mapping. - Specialization/Generalization and Aggregation concepts. 3. Database Design Goals & Integrity Constraints - Goals: zero redundancy, lossless join, dependency preservation. - Integrity: Entity integrity (primary key), Referential integrity (foreign key), Domain integrity, User-defined constraints. 4. Keys & Functional Dependencies - Keys: Primary, Candidate, Superkey, Alternate, Foreign key. - Functional Dependency (A -> B), types: trivial, non-trivial, multivalued, transitive. - Armstrong's axioms and attribute closure for finding keys. - Minimal cover (canonical cover) computation steps. 5. Normalization & Normal Forms - Purpose: eliminate anomalies (insert, delete, update), reduce redundancy. - 1NF: atomic values, no multi-valued attributes. - 2NF: 1NF + no partial dependency on part of a composite key. - 3NF: 2NF + no transitive dependency; every non-prime attribute must depend on a superkey. - BCNF: Every FD's LHS is a superkey (stronger than 3NF). 6. Relational Algebra & Relational Calculus - Relational algebra operators: selection ( σ ), projection ( π ), Cartesian product (×), union (U), difference (-), rename ( ρ ), joins ( n ), division (/), intersection, outer joins. - Extended operators: aggregation, set operations, etc. - Relational calculus: tuple relational calculus & domain relational calculus (non-procedural). 7. SQL Essentials - Categories: DDL (CREATE, ALTER, DROP), DML (SELECT, INSERT, UPDATE, DELETE), DCL (GRANT, REVOKE). - SQL concepts: GROUP BY, HAVING, ORDER BY, subqueries, EXISTS, LIKE, IN, BETWEEN, aliases. - Execution flow: FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY. 8. File Structure & Indexing - File organizations: sequential, heap, hash, B+ tree, clustered. - Blocking factor, record blocks, average block accesses. - Indexing: single-level (primary sparse, secondary dense, clustering) and multi-level indexes; B-Tree and B+ Tree differences. 9. Transactions & Concurrency Control - Transaction properties (ACID): Atomicity, Consistency, Isolation, Durability. - Transaction states: Active -> Partially Committed -> Committed; Failed -> Aborted. - Concurrency control aims: serializability, locks, deadlock handling (wait-die, wound-wait), two-phase locking (2PL). 10. Recovery & Logging (Brief) - Recovery ensures durability and consistency after crashes. - Write-ahead logging, checkpoints, undo/redo protocols (ARIES-style concepts). 11. Additional Quick Topics - Normalization example steps, candidate key finding, minimal cover steps. - Index usage for query performance; trade-offs (insert/update cost vs read speed). - DBMS design goals recap and practical interview pointers. Study Tips: - Practice converting ER diagrams to relational schemas. - Practice SQL queries covering joins, window functions, groupings, and subqueries. - Understand normalization through examples and write out FD decompositions. - Be able to explain transactions, locking, and recovery with simple diagrams. - Use short notes & flashcards for key definitions; implement small examples in a DB (SQLite/MySQL).\",\"textTemplate\":\"\",\"metadataSeparator\":\"\\n\",\"type\":\"TEXT\",\"hash\":\"DQlRCjhG6757idCKN6Nc3AZXp2/e8clKvClHLZFoaIM=\"}","__type__":"TEXT"},"b76d8280-af53-44aa-9ad1-3e6d7d3cc2d3":{"__data__":"{\"id_\":\"b76d8280-af53-44aa-9ad1-3e6d7d3cc2d3\",\"metadata\":{\"domain\":\"dbms\",\"filename\":\"dbms_last_minute_notes_summary.pdf\"},\"excludedEmbedMetadataKeys\":[],\"excludedLlmMetadataKeys\":[],\"relationships\":{\"SOURCE\":{\"nodeId\":\"b1270b7d-ca8c-4d60-9c12-6dee82538e02\",\"metadata\":{\"domain\":\"dbms\",\"filename\":\"dbms_last_minute_notes_summary.pdf\"},\"hash\":\"WQHSBEaYQaFTCo5bPFMQyCbDuEA/6AZiTkmQRkxF1i0=\"}},\"text\":\"DBMS — Last-Minute Study Notes (Summary)  DBMS — Last-Minute Study Notes (Concise Summary) 1. Introduction - DBMS: Organized collection of interrelated data for efficient storage, retrieval, insertion, deletion. - Advantages over file system: concurrency, recovery, multi-user access, structured querying, data integrity. 2. ER Model (Entity-Relationship) - Entity: Real-world object (strong vs weak entities). - Attribute: Properties (key, composite, multivalued, derived). - Relationship: Association between entities; participation constraints: total vs partial. - Cardinalities: 1:1, 1:N, N:1, M:N. Mapping cardinalities determine relational table counts for ER->Relational mapping. - Specialization/Generalization and Aggregation concepts. 3. Database Design Goals & Integrity Constraints - Goals: zero redundancy, lossless join, dependency preservation. - Integrity: Entity integrity (primary key), Referential integrity (foreign key), Domain integrity, User-defined constraints. 4. Keys & Functional Dependencies - Keys: Primary, Candidate, Superkey, Alternate, Foreign key. - Functional Dependency (A -> B), types: trivial, non-trivial, multivalued, transitive. - Armstrong's axioms and attribute closure for finding keys. - Minimal cover (canonical cover) computation steps. 5. Normalization & Normal Forms - Purpose: eliminate anomalies (insert, delete, update), reduce redundancy. - 1NF: atomic values, no multi-valued attributes. - 2NF: 1NF + no partial dependency on part of a composite key. - 3NF: 2NF + no transitive dependency; every non-prime attribute must depend on a superkey. - BCNF: Every FD's LHS is a superkey (stronger than 3NF). 6. Relational Algebra & Relational Calculus - Relational algebra operators: selection ( σ ), projection ( π ), Cartesian product (×), union (U), difference (-), rename ( ρ ), joins ( n ), division (/), intersection, outer joins. - Extended operators: aggregation, set operations, etc. - Relational calculus: tuple relational calculus & domain relational calculus (non-procedural). 7. SQL Essentials - Categories: DDL (CREATE, ALTER, DROP), DML (SELECT, INSERT, UPDATE, DELETE), DCL (GRANT, REVOKE). - SQL concepts: GROUP BY, HAVING, ORDER BY, subqueries, EXISTS, LIKE, IN, BETWEEN, aliases. - Execution flow: FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY. 8. File Structure & Indexing - File organizations: sequential, heap, hash, B+ tree, clustered. - Blocking factor, record blocks, average block accesses. - Indexing: single-level (primary sparse, secondary dense, clustering) and multi-level indexes; B-Tree and B+ Tree differences. 9. Transactions & Concurrency Control - Transaction properties (ACID): Atomicity, Consistency, Isolation, Durability. - Transaction states: Active -> Partially Committed -> Committed; Failed -> Aborted. - Concurrency control aims: serializability, locks, deadlock handling (wait-die, wound-wait), two-phase locking (2PL). 10. Recovery & Logging (Brief) - Recovery ensures durability and consistency after crashes. - Write-ahead logging, checkpoints, undo/redo protocols (ARIES-style concepts). 11. Additional Quick Topics - Normalization example steps, candidate key finding, minimal cover steps. - Index usage for query performance; trade-offs (insert/update cost vs read speed). - DBMS design goals recap and practical interview pointers. Study Tips: - Practice converting ER diagrams to relational schemas. - Practice SQL queries covering joins, window functions, groupings, and subqueries. - Understand normalization through examples and write out FD decompositions. - Be able to explain transactions, locking, and recovery with simple diagrams. - Use short notes & flashcards for key definitions; implement small examples in a DB (SQLite/MySQL).\",\"textTemplate\":\"\",\"metadataSeparator\":\"\\n\",\"type\":\"TEXT\",\"hash\":\"DQlRCjhG6757idCKN6Nc3AZXp2/e8clKvClHLZFoaIM=\"}","__type__":"TEXT"}},"docstore/metadata":{"ced9502c-fbc9-4353-b116-42e210854a90":{"docHash":"WQHSBEaYQaFTCo5bPFMQyCbDuEA/6AZiTkmQRkxF1i0="},"a7d12320-a9ef-4489-a525-6949afb97dc2":{"docHash":"DQlRCjhG6757idCKN6Nc3AZXp2/e8clKvClHLZFoaIM=","refDocId":"ced9502c-fbc9-4353-b116-42e210854a90"},"b76d8280-af53-44aa-9ad1-3e6d7d3cc2d3":{"docHash":"DQlRCjhG6757idCKN6Nc3AZXp2/e8clKvClHLZFoaIM=","refDocId":"b1270b7d-ca8c-4d60-9c12-6dee82538e02"},"b1270b7d-ca8c-4d60-9c12-6dee82538e02":{"docHash":"WQHSBEaYQaFTCo5bPFMQyCbDuEA/6AZiTkmQRkxF1i0="}},"docstore/ref_doc_info":{"ced9502c-fbc9-4353-b116-42e210854a90":{"nodeIds":["a7d12320-a9ef-4489-a525-6949afb97dc2"],"extraInfo":{}},"b1270b7d-ca8c-4d60-9c12-6dee82538e02":{"nodeIds":["b76d8280-af53-44aa-9ad1-3e6d7d3cc2d3"],"extraInfo":{}}}}